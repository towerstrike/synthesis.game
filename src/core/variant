module core.variant;
import core.type;
import core.trait;
import core.platform;

template<typename... types>
template<typename target_type>
constexpr u64 variant<types...>::index_of() noexcept {
    u64 index = 0;
    ((is_same<target_type, types> ? true : (++index, false)) || ...);
    return index;
}

template<typename... types>
template<typename target_type>
    requires is_one_of<target_type, types...>
variant<types...>::variant(target_type value) noexcept
    : type_index(index_of<target_type>()) {
    construct(static_cast<target_type&&>(value));
}

template<typename... types>
variant<types...>::variant(const variant& other)
    : type_index(other.type_index) {
    copy_from(other);
}

template<typename... types>
variant<types...>& variant<types...>::operator=(const variant& other) {
    if (this != &other) {
        destroy();
        type_index = other.type_index;
        copy_from(other);
    }
    return *this;
}

template<typename... types>
variant<types...>::variant(variant&& other) noexcept
    : type_index(other.type_index) {
    move_from(static_cast<variant&&>(other));
}

template<typename... types>
variant<types...>& variant<types...>::operator=(variant&& other) noexcept {
    if (this != &other) {
        destroy();
        type_index = other.type_index;
        move_from(static_cast<variant&&>(other));
    }
    return *this;
}

template<typename... types>
variant<types...>::~variant() {
    destroy();
}

template<typename... types>
template<typename target_type>
    requires is_one_of<target_type, types...>
bool variant<types...>::holds() const noexcept {
    return type_index == index_of<target_type>();
}

template<typename... types>
template<typename target_type>
    requires is_one_of<target_type, types...>
target_type& variant<types...>::get() {
    if (unlikely(!holds<target_type>())) {
        __builtin_trap();
    }
    return *reinterpret_cast<target_type*>(storage);
}

template<typename... types>
template<typename target_type>
    requires is_one_of<target_type, types...>
const target_type& variant<types...>::get() const {
    if (unlikely(!holds<target_type>())) {
        __builtin_trap();
    }
    return *reinterpret_cast<const target_type*>(storage);
}

template<typename... types>
template<typename target_type>
    requires is_one_of<target_type, types...>
target_type* variant<types...>::get_if() noexcept {
    if (holds<target_type>()) {
        return reinterpret_cast<target_type*>(storage);
    }
    return null;
}

template<typename... types>
template<typename target_type>
    requires is_one_of<target_type, types...>
const target_type* variant<types...>::get_if() const noexcept {
    if (holds<target_type>()) {
        return reinterpret_cast<const target_type*>(storage);
    }
    return null;
}

template<typename... types>
u64 variant<types...>::index() const noexcept {
    return type_index;
}

template<typename... types>
template<typename target_type>
void variant<types...>::construct(target_type&& value) noexcept {
    new(storage) remove_reference_type<target_type>(static_cast<target_type&&>(value));
}

template<typename... types>
void variant<types...>::destroy() noexcept {
    u64 current_index = 0;
    (((current_index++ == type_index) ? (reinterpret_cast<types*>(storage)->~types(), true) : false) || ...);
}

template<typename... types>
void variant<types...>::copy_from(const variant& other) {
    u64 current_index = 0;
    (((current_index++ == type_index) ? (new(storage) types(*reinterpret_cast<const types*>(other.storage)), true) : false) || ...);
}

template<typename... types>
void variant<types...>::move_from(variant&& other) noexcept {
    u64 current_index = 0;
    (((current_index++ == type_index) ? (new(storage) types(static_cast<types&&>(*reinterpret_cast<types*>(other.storage))), true) : false) || ...);
}

template<typename target_type, typename... types>
    requires is_one_of<target_type, types...>
target_type& get(variant<types...>& v) {
    return v.template get<target_type>();
}

template<typename target_type, typename... types>
    requires is_one_of<target_type, types...>
const target_type& get(const variant<types...>& v) {
    return v.template get<target_type>();
}

template<typename target_type, typename... types>
    requires is_one_of<target_type, types...>
target_type* get_if(variant<types...>* v) noexcept {
    return v ? v->template get_if<target_type>() : null;
}

template<typename target_type, typename... types>
    requires is_one_of<target_type, types...>
const target_type* get_if(const variant<types...>* v) noexcept {
    return v ? v->template get_if<target_type>() : null;
}

template<typename... types>
template<typename visitor_type>
auto variant<types...>::visit(visitor_type visitor) const {
    return visit_impl(visitor, make_index_sequence<sizeof...(types)>{});
}

template<typename... types>
template<typename visitor_type>
auto variant<types...>::visit(visitor_type visitor) {
    return visit_impl(visitor, make_index_sequence<sizeof...(types)>{});
}

template<typename... types>
template<typename visitor_type, u64... indices>
auto variant<types...>::visit_impl(visitor_type visitor, index_sequence<indices...>) const {
    using return_type = common_return_type<visitor_type, types...>;
    
    static constexpr auto vtable = make_vtable<visitor_type, return_type, indices...>();
    return vtable[type_index](visitor, storage);
}

template<typename... types>
template<typename visitor_type, u64... indices>
auto variant<types...>::visit_impl(visitor_type visitor, index_sequence<indices...>) {
    using return_type = common_return_type<visitor_type, types...>;
    
    static constexpr auto vtable = make_vtable<visitor_type, return_type, indices...>();
    return vtable[type_index](visitor, storage);
}

template<typename... types>
template<typename visitor_type, typename return_type, u64... indices>
constexpr auto variant<types...>::make_vtable() noexcept {
    using vtable_func = return_type(*)(visitor_type&, const u8*);
    return array<vtable_func, sizeof...(types)>{
        [](visitor_type& visitor, const u8* storage) -> return_type {
            return visitor(*reinterpret_cast<const nth_type<indices, types...>*>(storage));
        }...
    };
}

template<typename visitor_type, typename... types>
auto visit(visitor_type visitor, const variant<types...>& v) {
    return v.visit(visitor);
}

template<typename visitor_type, typename... types>
auto visit(visitor_type visitor, variant<types...>& v) {
    return v.visit(visitor);
}